# Acwing-1453：移掉k位数字

[原题链接](https://www.acwing.com/problem/content/1455/)

## 题目描述

给定一个以字符串表示的非负整数 *num*​，移除这个数中的 *k*​ 位数字，使得剩下的数字最小。

**注意：**

- 空字符串被视为 *0*。
- 如果结果中包含前导零，则需要将前导零删除，最后删除的前导零不用包含在移除的 *k*​ 个数字中。



**输入格式**

第一行输入一个字符串，用来表示非负整数 *num*​

第二行输入一个整数，表示 *k*​

**输出格式**

输出一个字符串，表示移除 *k​* 位数字后所能得到的最小数字。

**数据范围**

*0≤k≤​* 字符串长度 *≤100000*，
*num​* 中不包含任何前导 *0​*。



**输入样例：**

```
1432219
3
```

**输出样例：**

```
1219
```

**样例解释**

移除掉三个数字 *4,3,2​* 可形成一个新的最小的数字 *1219​*。



## 解题思路

核心：**位于前方的数** 对 整体数的**大小**的影响力 *大于*  **位于后方的数**

1. *num* 单调上升

   形如 *12345678​*，若要删掉 ​*k​* 位数字，应删除后 ​*k​* 位。

   因为若删除前面的小数，后面的大数会向前移动，从而使数增大。

2. *num* 非单调上升

   当第 *k​* 位数大于第 *k+1* 位数时，有两种选择

   * 删除第 *k​* 位数
   * 不删除第 *k​* 位数

   删除会使小数前移，根据**核心**原理可知，*删后的数**一定**比不删的数**小***

故此题可用贪心思想解决



## 代码

```c++
#include <iostream>

using namespace std;

int main() {
    string num;
    int k;
    cin >> num >> k;
    
    // 初始化为"0"，可避免字符串为空情况发生
    string res = "0";
    
    // 字符串非单调上升
    for(auto c : num) {
        while(k && c < res.back()) {
            res.pop_back();
            k --;
        }
        res += c;
    }
    
    // 字符串单调上升
    while(k --) res.pop_back();
    
    // 去除前导0
    k = 0;
    while(k + 1 < res.size() && res[k] == '0')  k ++;
    
    cout << res.substr(k) << endl;
    
    return 0;
}
```

